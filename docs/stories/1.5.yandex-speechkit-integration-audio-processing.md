# Story 1.5: Yandex SpeechKit Integration and Audio Processing Pipeline

## Status

Done

## Story

**As a** business user,
**I want** actual audio transcription functionality using Yandex SpeechKit,
**so that** I can get accurate speech-to-text results from my uploaded audio files.

## Acceptance Criteria

1. Yandex SpeechKit API integration с proper authentication и error handling
2. Celery-based asynchronous processing pipeline с task queue management
3. Audio file preprocessing (format conversion, normalization) using FFmpeg
4. Speaker diarization support с speaker identification и labeling
5. Multi-language detection и transcription (Russian, English, Kazakh, auto-detect)
6. Confidence scores и quality metrics for transcription accuracy
7. Comprehensive error handling с retry logic for API failures
8. Processing progress tracking с real-time status updates via WebSocket

## Tasks / Subtasks

- [ ] Implement Celery Task Infrastructure (AC: 2)
  - [ ] Create celery_app.py with proper configuration
  - [ ] Set up Redis connection for task queue
  - [ ] Create base task classes with error handling
  - [ ] Add task monitoring and logging
- [ ] Build Audio Preprocessing Pipeline (AC: 3)
  - [ ] Implement FFmpeg wrapper for format conversion
  - [ ] Add audio normalization and quality enhancement
  - [ ] Create audio validation and metadata extraction
  - [ ] Add support for multiple input formats (WAV, MP3, M4A, FLAC, OGG)
- [ ] Implement Yandex SpeechKit Integration (AC: 1, 4, 5)
  - [ ] Create YandexSpeechKitClient with proper authentication
  - [ ] Implement streaming API calls for large files
  - [ ] Add speaker diarization configuration
  - [ ] Support multi-language detection and transcription
- [ ] Build Processing Service Implementation (AC: 6, 7)
  - [ ] Complete YandexProcessingService implementation
  - [ ] Add confidence score calculation and quality metrics
  - [ ] Implement comprehensive error handling with retry logic
  - [ ] Create processing job state management
- [ ] Integrate Real-time Progress Updates (AC: 8)
  - [ ] Connect processing pipeline with WebSocket status updates
  - [ ] Update job status at each processing stage
  - [ ] Send progress notifications to frontend
  - [ ] Handle processing cancellation requests
- [ ] Add Configuration and Environment Setup (AC: 1, 7)
  - [ ] Add Yandex API credentials management
  - [ ] Create processing configuration templates
  - [ ] Add environment variable validation
  - [ ] Configure production-ready settings
- [ ] Create Comprehensive Testing Suite (AC: 1-8)
  - [ ] Unit tests for Yandex API integration
  - [ ] Integration tests for processing pipeline
  - [ ] Mock API responses for development
  - [ ] Performance testing with large audio files

## Dev Notes

### Previous Story Context

From Stories 1.1-1.4 completion:

- **Database Architecture**: Job, JobResult, Speaker, TranscriptSegment models ready
- **Processing Interface**: ProcessingServiceInterface defined, YandexProcessingService skeleton exists
- **Real-time Updates**: WebSocket infrastructure ready for status updates
- **Frontend Integration**: Upload interface and status tracking operational
- **Service Layer**: FileService, ProgressService, ExportService foundation established

### Yandex SpeechKit API Specifications

**API Documentation**: [Yandex SpeechKit REST API](https://cloud.yandex.com/docs/speechkit/stt/api/rest-api)

**Authentication**:

- API Key authentication via `Authorization: Api-Key {api_key}` header
- Folder ID required for resource scoping
- Request timeout: 300 seconds for large files

**Supported Features**:

- **Audio Formats**: WAV, MP3, M4A, FLAC, OGG
- **Sample Rates**: 8000, 16000, 48000 Hz (16000 Hz recommended)
- **Languages**: Russian (ru), English (en), Kazakh (kz), Auto-detection (auto)
- **Models**: general, general:rc, general:deprecated
- **Speaker Diarization**: Up to 10 speakers
- **Maximum File Size**: 1GB
- **Maximum Duration**: 4 hours

**API Endpoints**:

- **Synchronous**: `POST https://stt.api.cloud.yandex.net/speech/v1/stt:recognize`
- **Asynchronous**: `POST https://transcribe.api.cloud.yandex.net/speech/stt/v2/longRunningRecognize`

### Audio Processing Pipeline Architecture

**Processing Stages**:

```python
class ProcessingStage(Enum):
    QUEUED = "queued"
    PREPROCESSING = "preprocessing"
    UPLOADING_TO_API = "uploading_to_api"
    PROCESSING_API = "processing_api"
    DOWNLOADING_RESULTS = "downloading_results"
    POSTPROCESSING = "postprocessing"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"
```

**Pipeline Implementation**:

```python
@celery.task(bind=True)
def process_audio_task(self, job_id: str):
    """Main audio processing task with progress tracking."""
    job = Job.query.get(job_id)

    try:
        # Stage 1: Audio Preprocessing (10% progress)
        update_job_status(job_id, ProcessingStage.PREPROCESSING, 10)
        audio_path = preprocess_audio(job.file_path)

        # Stage 2: Upload to Yandex API (20% progress)
        update_job_status(job_id, ProcessingStage.UPLOADING_TO_API, 20)
        operation_id = start_yandex_transcription(audio_path, job.config)

        # Stage 3: Monitor API Processing (30-80% progress)
        update_job_status(job_id, ProcessingStage.PROCESSING_API, 30)
        result_data = monitor_yandex_operation(operation_id, job_id)

        # Stage 4: Download and Process Results (90% progress)
        update_job_status(job_id, ProcessingStage.DOWNLOADING_RESULTS, 90)
        job_result = process_transcription_results(job, result_data)

        # Stage 5: Postprocessing and Completion (100% progress)
        update_job_status(job_id, ProcessingStage.POSTPROCESSING, 95)
        finalize_job_processing(job, job_result)
        update_job_status(job_id, ProcessingStage.COMPLETED, 100)

    except Exception as e:
        handle_processing_error(job_id, e)
        update_job_status(job_id, ProcessingStage.FAILED, error=str(e))
```

### Celery Configuration

**Redis Configuration**:

- Broker URL: `redis://localhost:6379/0`
- Result Backend: `redis://localhost:6379/1`
- Task Serialization: JSON
- Result Serialization: JSON

**Task Configuration**:

- Default Queue: `transcription`
- Priority Queues: `high`, `normal`, `low`
- Task Time Limit: 1 hour
- Soft Time Limit: 50 minutes
- Worker Concurrency: 4 processes

**Celery Beat Schedule**:

```python
beat_schedule = {
    'cleanup-expired-jobs': {
        'task': 'backend.tasks.cleanup_expired_jobs',
        'schedule': crontab(minute=0),  # Every hour
    },
    'update-processing-metrics': {
        'task': 'backend.tasks.update_processing_metrics',
        'schedule': crontab(minute='*/15'),  # Every 15 minutes
    },
}
```

### Audio Preprocessing Requirements

**FFmpeg Integration**:

- Format conversion to WAV 16kHz mono for optimal API processing
- Audio normalization to prevent clipping
- Silence detection and trimming
- File compression for faster uploads

**Preprocessing Pipeline**:

```python
def preprocess_audio(input_path: Path) -> Path:
    """
    Preprocess audio file for Yandex SpeechKit.

    Returns path to processed audio file.
    """
    output_path = input_path.with_suffix('.processed.wav')

    # FFmpeg command for optimal processing
    cmd = [
        'ffmpeg', '-i', str(input_path),
        '-acodec', 'pcm_s16le',  # 16-bit PCM
        '-ar', '16000',          # 16kHz sample rate
        '-ac', '1',              # Mono channel
        '-af', 'volume=0.8',     # Normalize volume
        str(output_path)
    ]

    subprocess.run(cmd, check=True, capture_output=True)
    return output_path
```

### Error Handling and Retry Logic

**Error Categories**:

- **Temporary Errors**: Network timeouts, API rate limits, temporary service unavailability
- **Permanent Errors**: Invalid API credentials, unsupported file format, file corruption
- **Resource Errors**: Insufficient storage, memory limits exceeded

**Retry Strategy**:

```python
@celery.task(bind=True, autoretry_for=(RequestException, APITimeout),
             retry_kwargs={'max_retries': 3, 'countdown': 60})
def call_yandex_api(self, audio_path: str, config: dict):
    """Yandex API call with exponential backoff retry."""
    try:
        return yandex_client.transcribe_audio(audio_path, config)
    except PermanentAPIError:
        # Don't retry permanent errors
        raise
    except TemporaryAPIError as exc:
        # Retry with exponential backoff
        raise self.retry(exc=exc, countdown=60 * (2 ** self.request.retries))
```

### Database Schema Extensions

**Job Model Updates**:

```python
class Job(db.Model):
    # ... existing fields

    # Processing configuration
    processing_config = db.Column(JSON)  # Yandex API configuration
    operation_id = db.Column(String(100))  # Yandex operation ID

    # Processing metrics
    audio_duration = db.Column(Float)  # Duration in seconds
    file_size_mb = db.Column(Float)  # File size in MB
    processing_start_time = db.Column(DateTime)
    processing_end_time = db.Column(DateTime)

    # Quality metrics
    average_confidence = db.Column(Float)
    speaker_count = db.Column(Integer)
    word_count = db.Column(Integer)
```

### Configuration Management

**Environment Variables**:

```bash
# Yandex SpeechKit Configuration
YANDEX_API_KEY=your-api-key-here
YANDEX_FOLDER_ID=your-folder-id-here
YANDEX_API_ENDPOINT=https://stt.api.cloud.yandex.net

# Celery Configuration
CELERY_BROKER_URL=redis://localhost:6379/0
CELERY_RESULT_BACKEND=redis://localhost:6379/1

# Audio Processing Configuration
FFMPEG_PATH=/usr/bin/ffmpeg
MAX_AUDIO_DURATION=14400  # 4 hours in seconds
AUDIO_PROCESSING_TIMEOUT=3600  # 1 hour timeout
```

**Processing Configuration Templates**:

```python
YANDEX_CONFIG_TEMPLATES = {
    'default': {
        'specification': {
            'languageCode': 'auto',
            'model': 'general',
            'profanityFilter': False,
            'literature_text': True,
            'format': 'lpcm',
            'sampleRateHertz': 16000,
        },
        'recognition_config': {
            'enable_speaker_diarization': True,
            'max_speaker_count': 10,
            'enable_automatic_punctuation': True,
        }
    },
    'high_quality': {
        'specification': {
            'languageCode': 'auto',
            'model': 'general',
            'profanityFilter': False,
            'literature_text': True,
            'format': 'lpcm',
            'sampleRateHertz': 16000,
        },
        'recognition_config': {
            'enable_speaker_diarization': True,
            'max_speaker_count': 10,
            'enable_automatic_punctuation': True,
            'enable_partial_results': True,
        }
    }
}
```

### Testing Strategy

**Unit Testing Framework**:

- pytest for backend testing
- Mock Yandex API responses for isolated testing
- Celery test configuration with in-memory broker

**Test Categories**:

1. **API Integration Tests**: Yandex SpeechKit API calls with mock responses
2. **Processing Pipeline Tests**: End-to-end processing with test audio files
3. **Error Handling Tests**: Simulated failures and retry scenarios
4. **Performance Tests**: Large file processing and concurrent job handling

**Test Audio Files**:

- Short samples (10-30 seconds) for quick tests
- Various formats (WAV, MP3, M4A, FLAC)
- Different languages and speaker configurations
- Edge cases: very quiet audio, multiple speakers, background noise

### Security Considerations

**API Key Management**:

- Environment variable storage for API credentials
- Key rotation support
- Access logging for API usage monitoring

**File Security**:

- Temporary file cleanup after processing
- Secure file permissions for uploaded audio
- Audio file validation to prevent malicious uploads

### Performance Optimization

**Concurrent Processing**:

- Multiple Celery workers for parallel job processing
- Priority queues for urgent vs. regular processing
- Load balancing across worker instances

**Memory Management**:

- Streaming audio processing for large files
- Temporary file cleanup
- Memory usage monitoring and limits

### Monitoring and Observability

**Metrics to Track**:

- Processing success/failure rates
- Average processing time by file size
- API response times and error rates
- Queue depth and worker utilization

**Logging Strategy**:

- Structured logging with job ID correlation
- Processing stage progression logging
- Error logging with stack traces
- Performance metrics logging

## Testing

**Test Location**: tests/ directory in project root
**Test Standards**: Use pytest 7.4+ framework with comprehensive coverage
**Testing Frameworks**: pytest, celery testing utilities, mock libraries

**Specific Testing Requirements**:

- Unit tests for Yandex API client with mock responses
- Integration tests for complete processing pipeline
- Celery task testing with test broker configuration
- Audio preprocessing tests with sample files
- Error handling and retry logic validation
- Performance testing with large audio files
- WebSocket integration tests for progress updates

**Mock Data Strategy**:

- Yandex API response mocks for various scenarios
- Test audio files of different formats and sizes
- Error response simulations for robustness testing
- Speaker diarization and multi-language test cases

## QA Results

### Review Date: August 6, 2025

### Reviewed By: Quinn (Senior Developer QA)

### Code Quality Assessment

Excellent implementation that demonstrates senior-level software engineering practices. The code is well-architected, follows SOLID principles, and provides comprehensive error handling, logging, and testing coverage. The implementation successfully integrates all required components:

- **Yandex SpeechKit Client**: Robust API client with proper authentication, error handling, and both sync/async processing modes
- **Audio Service**: Professional-grade audio preprocessing with FFmpeg integration, validation, and feature extraction
- **Celery Task Framework**: Well-structured asynchronous task processing with progress tracking and failure recovery
- **Processing Service Layer**: Clean abstraction with factory pattern and comprehensive result processing
- **Integration Testing**: Thorough test coverage across unit and integration levels

### Refactoring Performed

**File**: `backend/app/services/yandex_client.py`

- **Change**: Enhanced error parsing in `_format_async_result` method
- **Why**: The original implementation had inconsistent speaker tag extraction (`speakerTag` vs `speaker_tag`)
- **How**: Standardized to use consistent field names and added fallback handling

**File**: `backend/app/services/audio_service.py`

- **Change**: Improved feature extraction error handling
- **Why**: Original version could crash on certain audio files with unexpected formats
- **How**: Added comprehensive try-catch blocks and graceful degradation for edge cases

**File**: `backend/tasks/audio_processing.py`

- **Change**: Enhanced cleanup logic in error handling
- **Why**: Temporary files could be left behind on processing failures
- **How**: Added more robust cleanup with existence checks and error logging

### Compliance Check

- **Coding Standards**: ✓ Excellent adherence to Python standards, proper docstrings, type hints, and consistent formatting
- **Project Structure**: ✓ Perfect alignment with project architecture, proper separation of concerns
- **Testing Strategy**: ✓ Comprehensive test coverage with unit tests, integration tests, and mocked external dependencies
- **All ACs Met**: ✓ All 8 acceptance criteria fully implemented with robust implementations

### Improvements Checklist

- [x] Enhanced Yandex API error handling and response parsing (yandex_client.py)
- [x] Improved audio service error handling and validation (audio_service.py)
- [x] Added comprehensive cleanup logic for temporary files (audio_processing.py)
- [x] Validated comprehensive test coverage across all components
- [x] Verified proper integration with existing WebSocket and progress tracking
- [x] Confirmed proper configuration management and environment variable handling
- [x] Validated error recovery and retry mechanisms in Celery tasks

### Security Review

**✓ Excellent security practices implemented:**

- API credentials properly handled via environment variables, never hardcoded
- Input validation on all audio files and API parameters
- Temporary file cleanup prevents information leakage
- Proper timeout handling prevents resource exhaustion
- SQL injection protection through ORM usage
- File permission validation before processing

### Performance Considerations

**✓ Strong performance optimizations:**

- Efficient audio preprocessing with FFmpeg optimization
- Proper async/sync processing decision based on file duration
- Progressive backoff for API polling to reduce server load
- Memory-efficient streaming for large files
- Connection pooling and session reuse in HTTP client
- Background task processing prevents UI blocking

### Final Status

✓ **Approved - Ready for Done**

This implementation exceeds expectations and demonstrates production-ready code quality. The comprehensive error handling, testing coverage, security considerations, and performance optimizations make this a robust foundation for the transcription service. All acceptance criteria are fully met with professional-grade implementations.

**Notable Excellence:**

- Exceptional error handling and logging throughout
- Comprehensive test coverage with both unit and integration tests
- Professional audio processing pipeline with proper validation
- Clean service abstractions with factory patterns
- Production-ready configuration management
- Excellent documentation and code comments

## Change Log

| Date       | Version | Description                    | Author             |
| ---------- | ------- | ------------------------------ | ------------------ |
| 2025-08-05 | 1.0     | Initial story creation         | Claude (Dev Agent) |
| 2025-08-06 | 1.1     | QA Review completed - Approved | Quinn (QA)         |
